现在有五款主要的浏览器：Internet Explorer、Firefox、Safari、Chrome和Opera。
浏览器的主要功能是展现你所需要的web资源，它从服务器端请求资源并显示在浏览器窗口上，
资源格式一般为html，但是也可以是pdf，image或者其他的格式。
资源的地址是由用户同规格URI(统一资源定位符)来指定的。
浏览器的主要结构如下：
  1.用户界面-包括地址栏、后退/前进按钮、书签菜单等
  2.浏览器引擎-询问和操作渲染引擎的接口
  3.渲染引擎-负责展现所请求的内容，比如如果请求的是html，它就负责解析html和css并且在屏幕上曾宪解析后的内容。
  4.网络模块-网络请求用，比如http请求。它有跨平台的接口以及对应于每个平台的底层实现。
  5.UI后端-用来绘制基本构件，如下拉框和窗口。UI后端暴露出一个平台无关性的公共接口，底层的它使用操作系统的UI方法。
  6.javascript解释器-用来解析和执行javascript代码。
  7.数据存储-这是一个可存储的曾。浏览器需要在硬盘上保存各种数据，比如cookies。

我们提到的浏览器-Firefox、Charome和Safari基于两个渲染引擎。
Firefox使用Geokeo——一个Mozilla自制的渲染引擎，
Safari和Chrome都是用webkit。
Webkit是源于linux平台的一个开源渲染引擎。

渲染引擎开始会从网络模块获取要请求的文档内容,一般会以8K大小的区块获取.
渲染引擎开始解析HTML文档,并且把标签转换成"内容树"上的DOM节点,然后会解析样式,包括外部的css文件和style元素里的数据.
这些样式信息将会和HTML中视觉性的属性组合在一起创建另一个树--渲染树
渲染树由带有颜色和大小等视觉属性的矩形区域构成,这些矩形区域按它们将要显示在屏幕上的顺序排列.
渲染树构造完成后,进入到布局阶段,会把每个节点精确地调整到它应该在屏幕上出现的位置行.
下一步是绘制,渲染树将会被遍历,每个节点都会通过UI后端层来绘制.
为了有更好的用户体验,渲染引擎将会尽可能早的把内容在屏幕上显示出来,不会等到所有的HTML都被解析完才开始建造和布局渲染树,当进程还在继续解析源源不断的来自网络的内容的时候,一部分内容会被解析并且显示出来.

解析文档的意思是把文档转成有意义的一些结构-代码能够理解并且使用的东西,解析后的结果通常是一个能表现文档结构的节点树,叫做解析树或者语法树

解析是根据文档所遵循的语法规则--文档被写成的语言或者格式,每种格式都必须有由词典和语法规则组成的确定的语法,这被叫做上下文无关语法

解析可以分成两个子过程--词法分析和语法分析

词法分析是把输入信息分成多个子串的过程,这些子串是这个语言的词典--有效构造块的集合,在人类语言中包括在词典中出现的所有词汇.

语法分析是语言语法规则的应用

解析器通常把这个工作分给两个部件--负责把输入信息分成有效子串的词法分析器(有时被叫做编译器),以及负责根据语法规则分析文档结构并构建解析树的解析器,词法分析器知道怎么去分解诸如空格和换行等无关紧要的字符

这个解析过程是迭代的.解析器通常会向词法分析器请求新的子串然后试图用某些语法规则来匹配这个子串,
如果匹配了,会在解析树上加上这个子串相应的节点,然后请求新的子串;
如果没有匹配,解析器将会在内部保存这个子串,然后继续请求新的子串直到内部保存的子串匹配了一个规则.
如果没有规则可以匹配,解析器将会报出一个异常,这意味着文档是不合法的,包含着一个语法错误.

很多时候解析树并不是最终的结果.在转换中经常使用解析--把文档转换成另一种格式.
有个例子是编译,负责把原代码编译成机器代码的编译器会先把文档解析成解析树,然后把解析树转换成机器代码的文档.


有两种基本类型的解析器--自上而下的和自下而上的解析器,直观的解释就是自上而下的解析器观察语法的整体结构然后尝试匹配,
  自下而上的解析器则是从低级别的规则开始直到符号高级别的规则,把式子逐步的转换成语法规则.

HTML的定义时DTD格式的,这种格式被用来定义SGML系列的语言,包含所有允许元素的定义、它们的属性和层次结构.
DTD有几种变化形式,strict模式完全的遵守规范,其他模式则支持早起浏览器用到的标记,这是为了向后和以前的内容兼容.

输出树--解析树是一个带有DOM元素和属性节点的树,DOM是文档对象模型的简称,
它是HTML文档的对象表示方式,也是HTML元素面向外部世界如javascript的接口.

树的根节点是Document对象

树是由实现DOM接口的元素构建的

HTML5规范中详细描述了解析算法,算法由两个过程组成--断词和树构造.
断词是词法分析,把初始内容解析成子串,在HTML中子串是开始标签、结束标签、属性名和属性值,
分词器识别子串,交给树构造,然后从下一个字符来识别下一个子串,以此类推直到内容的结束.

分词算法返回的是一个HTML子串,算法以状态机来表示.
每个状态消耗输入内容的一或多个字符并且依据这些字符来更新下一个状态,
指令是受当前分词状态和树构造状态影响的,这意味着根据当前状态,同样的字符会产生不同的结果交给下一个状态

<html>
  <body>
    Hello world
  </body>
</html>
初始状态是"数据状态",当遇到"<"符号的时候,状态变成"标签开放状态",
"a-z"的字符会导致产生一个"标签开始标志位",状态变成"标签名状态",
这个状态会延续到遇到一">"符号,每个字符都会被装到这个新的标记名里.
当到达了">"符号的时候,当前标志位被释放,状态变回"数据状态","<body>"标签通过同样的步骤处理.
现在"html"和"body"标签都被释放了,我们又回到了"数据状态",
"Hello world"的"H"会导致一个字符标记的生成和释放,这会延续到遇到"</body>"的"<",
我们将会为"Hello world"的每个字符都释放一个字符标记.
现在我们回到了"标签开放状态",下一个字符"/"会导致一个"标签闭合标记"的产生,还有状态会变成"标签名状态",
我们又一次延续这个状态直到遇到">"符号,然后新的标签标记被释放,重新回到"数据状态","</html>"会像上一个情况一样处理.

当解析器被创建的时候文档对象也被创建了,在树构造阶段,以Document为根节点的DOM树将被修改,元素被添加上去,分词器释放的每个节点都会被树构造器处理.
对于每一个标记,规范都定义了是哪个DOM元素和它对应.
这些标记除了添加到DOM树上,还会加入到开放元素的栈上,这个栈是用来修正嵌套不匹配以及没闭合的标签的.
这个算法也以状态机来表示,这些状态叫做"接入模式".


解析器把分好词的内容解析成文档并构建文档树,如果文档树结构良好,解析就很容易了,但是我们需要处理很多结构不良的HTML文档,解析器也不得不容忍这些错误.
我们至少要处理下面几种情况
  1.将要添加的元素被明确禁止出现在某些标签里面.这种情况,我们应该闭合所有标签直到禁止这个元素的标签,然后在它后面添加
  2.不允许直接添加这个元素.可能是写代码的人漏掉了一些标签(或者标签是可选的),
  3.在内联元素里添加块状元素,闭合所有的内联元素直到下个块状元素
  4.如果还不行,在允许添加这个元素之前闭合前面元素,要不就忽略这个标签.

  webkit使用Flex and Bison解析器生成器来根据CSS语法文件自动的生成解析器,如你再解析器概述里了解的,Bison生成一个自下向上的移位规约解析器.
  Firefox使用的是手动编写的自上向下的解析器,这两种情况css文件都会被解析成一个StyleSheet对象,每个对象包含css规则,CSSrule对象包含选择器和声明对象以及符合CSS规则的其他对象.

  渲染对象和dOM元素是相一致的,但是并不是一对一的关系,非可见元素不会被插入到渲染树上,
  有个例子是"head"元素,还有display属性为none的元素不会出现在书中(visibility为hidden的元素会出现).

  有的DOM元素对应好几个可见元素,它们通常都有一个独立的矩形区域描述不了的复杂结构,
  例如"select"元素有三个渲染对象--一个负责显示区域,一个负责下拉列表框,还有一个负责按钮.
  还有当行宽不够文本被切成多行的时候,新行会作为额外的解析器被添加.
  另一个有多个渲染对象的是不合法的HTML.根据cSS规范,一个内联元素要么只包含块状元素,要么只包含内联元素,万一有混合型的内容,
  会创建匿名的块状渲染对象来包裹内联元素.
  有的渲染对象对应一个DOM节点但是在树中不是同样的位置.浮动和固定定位的元素脱离文档流,被放置在树上不同的位置,然后映射到实际的渲染对象上,在它们应该在的位置上有个占位帧.
  
  viewport是初始包含块,在webkit中是renderview对象