/**
 * javascript代码运行时,会产生一个全局的上下文环境,又称运行环境,包含了当前所有的变量和对象.
 * 然后,执行函数(或块级代码)的时候,又会在当前上下文环境的上层,产生一个函数运行的上下文,
 * 变成当前的上下文,由此形成一个上下文环境的堆栈.
 * 
 * 这个堆栈是"后进先出"的数据结构,最后产生的上下文环境首先执行完成,退出堆栈,
 * 然后再执行完成它下层的上下文,直至所有代码执行完成,堆栈清空.
 * 
 * Generator函数不是这样,它执行产生的上下文环境,一旦遇到yield命令,就会暂时退出堆栈,但是并不消失,
 * 里面的所有变量和对象会冻结在当前状态.
 * 等到对它执行next命令时,这个上下文环境又会重新加入调用栈,冻结的变量和对象恢复执行.
 */
function* gen() {
  yield 1;
  return 2;
}
let g = gen();
console.log(
  g.next().value,
  g.next().value
)
/**
 * 上面代码中,第一次执行g.next()时,Generator函数gen的上下文会加入堆栈,即开始运行gen内部的代码.
 * 等遇到yield 1时,gen上下文退出堆栈,内部状态冻结.
 * 第二次执行g.next()时,gen上下文重新加入堆栈,变成当前的上下文,重新恢复执行.
 */